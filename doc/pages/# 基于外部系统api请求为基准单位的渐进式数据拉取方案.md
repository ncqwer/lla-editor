# 基于外部系统api请求为基准单位的渐进式数据拉取方案

> 背景: 现在系统中使用的部分数据缺失，需要通过外部api的方式进行获取。其中外部api按照其来源，又可以分为公开免费和付费商用两种形式。在考虑数据一致性和数据实效性的需求背景下，我们提出一种业务模型，该模型能有效的兼顾性价比，api可访问性等因素的同时保证需求的满足。

## 方案设计

在数据同步方案的实现过程中，往往存在着以下的朴素思路：
1. 明确一种需求，（实际中，需求往往以需要查看某类数据的形式出现，即系统对外提供的api调用）
2. 明确需求所涉及的一组外部api，这往往以人工的形式解决。
3. 将外部api的文档和实际需求相结合，明确以何种方式调度外部api的方式的调用以及以何种形式缓存获取的数据。
4. 按照具体的需求，编写特定形式api接口，对外提供数据查询服务。

在上述流程中，我们将第3步所涉及的流程通称为**缓存数据**，将第四步所涉及的流程统称为**查询数据**。在解决某类需求的过程中，缓存数据往往与查询数据成对出现，一一对应，故本方案以其作为基准模型。

### 基准模型的探讨

#### 延迟化数据拉取

将缓存数据与查询数据看作两类带副作用的函数。

$$ f_{缓存数据}(参数_{缓存数据}) = 缓存层 $$

$$ f_{查询数据}(参数_{查询数据}) = 需求 $$

这两类函数的输入端数据在往往由需求端所确定。例如在查询最大N组A值的需求里

```ts
type AsMaxNN{
	nValue: number;
	others: any;
}

type fetchAs = Omit<'nValue',AsMaxN>;
```
通过上述的例子可以看出,缓存数据的参数是查询数据参数的子集。即 $参数_{缓存数据}\subset{参数_{查询数据}}$。

这一发现蕴含了一种可能性，即系统可以在没有执行缓存数据操作的情况下对外提供数据查询服务。（在判断数据不存在的时候才执行缓存操作），这就是延迟化数据拉取。
> 这种延迟执行的策略可以有效的避免对付费api的无效访问。这也是整个方案可以渐进式拉去数据的最为重要的基础。

#### 锁的考量

将需求映射为基准模型，基准模型的数据查询过程即为需求的实现。实际应用时，一个基准模型往往同时服务于一类数据请求，这类并发的数据请求可能会在数据残缺时同时到来。故，为了减少对外部api的无效调用，我们需要通过锁的方式来确保缓存数据的原子性。
这同时要求数据请求过程需要兼顾锁的状态。

#### 服务的可靠性

考虑以下关系，数据查询的结果一定在缓存数据的结果中，但缓存数据的结果并不一定在数据查询的结果中。即$Result_{Query}\subset{Result_{Fetch}}$。仅仅从网络io考量，一次10条的数据可能对应了1000条的数据更新。在数据残缺时，如果查询数据和缓存数据放在一次请求的生命周期中进行，这往往会导致请求的超时。请求时延的极大方差意味着服务的高度不可靠。仔细分析，这种不可靠性是由于缓存数据的不可靠性导致的（究其本质，是网络IO的不可靠性），故这启发了我们将缓存数据的过程移交到队列。

### 基准模型间的关系

一个实际运行的系统包含了多个需求的实现，即包含多个基准模型的存在。最简单的情况下，它们之间互不关联，彼此独立的运行。但是，需求总是复杂的。考虑一下两类需求

   - 查询一组公司的列表，对应了外部apiA
   - 查询特定公司的某一类属性, 对应了外部apiB

在这个场景中，调用apiB的时候需要apiA的返回值，即存在以下依赖链:

$$ Query_{B} \rightarrow Fetch_{B} \overset{某种依赖}{\rightarrow{Query_{A}}} \rightarrow Fetch_{A} $$

从基准模型的角度可能更加清晰:

$$ Model_{B} \overset{某种依赖}{\rightarrow} Model_A $$

这种依赖带来了逻辑上的前后顺序，而为了保证前后顺序的正确性（即数据的正确性和一致性），我们引入**版本**这个概念。

#### 版本的规律性

考虑一下依赖链：

$$  B \rightarrow A $$

朴素的认知上，一定存在着A处数据更新后B处数据才开始更新。如果以时间作为版本的刻度一定存在着$Time_A < Time_B$, 即

$$ Version_A \le Version_B $$

在广义的角度上，在放弃时间作为版本的尺度的考量下，这一规律仍旧具有普适性。即依赖项的更新一定会导致被依赖项的更新，但被依赖项的更新缺并不一定会导致依赖项的更新。只是此时，规律泛化到了

$$ Version_A \leq Version_B $$

## 方案的实现

> 本技术方案使用TypescriptV4实现


### 基准模型的接口

```ts
interface Strategy<Params=any>{
  getUniqueKey(params: Params): string; // 返回key用于业务锁，错误的记录
  queryData(params: Params, env: StrategyEnv): Promise<any>; // 数据查询

  whenDataIsNull(
    params: Params & { lockId: string },
    env: StrategyEnv
  ): Promise<any>; // 当前数据查询失败时，调用

  refreshCache(
    params: Params & { lockId: string },
    env: StrategyEnv
  ): Promise<any>; // 缓存数据
}

```

### 基准模型的联系

使用装饰器的方式，以声明式的方式定义依赖

```ts
delcare const StrategyDep = (StrategyCls: {new():Strategy},isDependencyStatisfied:()=>Promise<boolean>)=>ClassDecorator;
```
